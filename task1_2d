

% Extract and clean accelerometer data
accelData = permute(out.Sensor_ACCEL.signals.values, [3 2 1]);
timeVec   = out.Sensor_Time.time;
accelXY = accelData(:,1:2);
validInd = ~any(isnan(accelXY),2);
accelXY = accelXY(validInd,:);
timeVec = timeVec(validInd);

% Extract ground truth for evaluation
GT_pos = out.GT_position.signals.values;
N_gt = size(GT_pos,1);
N_time = length(timeVec);
N = min(N_gt, N_time);
GT_xy = GT_pos(1:N,1:2);
timeVec = timeVec(1:N);
accelXY = accelXY(1:N,:);

% Denoise accelerometer data by clipping outliers to [mean - std, mean + std]
accelXY_denoised = accelXY;
for j = 1:2
    mu = mean(accelXY(:,j));
    sigma = std(accelXY(:,j));
    lower_bound = mu - sigma;
    upper_bound = mu + sigma;
    idx_lower = accelXY(:,j) < lower_bound;
    idx_upper = accelXY(:,j) > upper_bound;
    accelXY_denoised(idx_lower,j) = lower_bound;
    accelXY_denoised(idx_upper,j) = upper_bound;
end

% Lowpass filter the denoised accelerometer data
fc = 5;
sampleInterval = 1/mean(diff(timeVec));
accelXY_filt = lowpass(accelXY_denoised, fc, 1/sampleInterval);

% Extract raw ToF readings
tof1_raw = out.Sensor_ToF1.signals.values(:,1);  % center/forward
tof2_raw = out.Sensor_ToF2.signals.values(:,1);  % right
tof3_raw = out.Sensor_ToF3.signals.values(:,1);  % left

% Determine ToF time vectors if available
if isfield(out.Sensor_ToF1,'time'), time_tof1 = out.Sensor_ToF1.time; else, time_tof1 = timeVec; end
if isfield(out.Sensor_ToF2,'time'), time_tof2 = out.Sensor_ToF2.time; else, time_tof2 = timeVec; end
if isfield(out.Sensor_ToF3,'time'), time_tof3 = out.Sensor_ToF3.time; else, time_tof3 = timeVec; end

% Interpolate ToF data onto the IMU time vector
tof1 = interp1(time_tof1, tof1_raw, timeVec, 'linear', 'extrap');
tof2 = interp1(time_tof2, tof2_raw, timeVec, 'linear', 'extrap');
tof3 = interp1(time_tof3, tof3_raw, timeVec, 'linear', 'extrap');

% Use the first few ground truth samples to estimate initial position
init_samples = 10;
x0 = mean(GT_xy(1:init_samples,:), 1);

% EKF initialization
x_est = zeros(4,1);
x_est(1:2) = x0';  % average initial position
x_est(3:4) = [0; 0];
P_est = diag([0.1, 0.1, 0.5, 0.5]);
Q = diag([0.01, 0.01, 0.1, 0.1]);
R = diag([0.05, 0.05, 0.05]);

% Known wall positions (assuming a 2.4m square arena)
D_front = 2.4;
D_right = 0;
D_left  = 2.4;

% ---------- Estimate ToF Biases from Initial Samples ----------
% For the first few samples, the expected measurement from each sensor is:
%   ToF1 (forward): 2.4 - x0(1)
%   ToF2 (right):   x0(2) - 0
%   ToF3 (left):    2.4 - x0(2)
% Compare to the actual ToF readings in the same interval.

actual_tof1 = mean(tof1(1:init_samples));
actual_tof2 = mean(tof2(1:init_samples));
actual_tof3 = mean(tof3(1:init_samples));

expected_tof1 = (D_front - x0(1));
expected_tof2 = (x0(2) - D_right);
expected_tof3 = (D_left - x0(2));

bias_tof1 = actual_tof1 - expected_tof1;
bias_tof2 = actual_tof2 - expected_tof2;
bias_tof3 = actual_tof3 - expected_tof3;

x_est_hist = zeros(4, N);
x_est_hist(:,1) = x_est;

for k = 1:N-1
    dt = timeVec(k+1) - timeVec(k);
    F = [1, 0, dt, 0;
         0, 1, 0, dt;
         0, 0, 1,  0;
         0, 0, 0,  1];
    B = [0.5*dt^2, 0;
         0, 0.5*dt^2;
         dt, 0;
         0, dt];
    u = accelXY_filt(k,:)';
    
    % Prediction
    x_pred = F*x_est + B*u;
    P_pred = F*P_est*F' + Q;
    
    % Correct the ToF measurements by subtracting the estimated biases
    z1 = tof1(k+1) - bias_tof1;
    z2 = tof2(k+1) - bias_tof2;
    z3 = tof3(k+1) - bias_tof3;
    z = [z1; z2; z3];
    
    % Measurement model
    h = [D_front - x_pred(1);
         x_pred(2) - D_right;
         D_left - x_pred(2)];
    
    H = [-1,  0, 0, 0;
          0,  1, 0, 0;
          0, -1, 0, 0];
    
    y_innov = z - h;
    S = H * P_pred * H' + R;
    K = P_pred * H' / S;
    
    % Update
    x_est = x_pred + K*y_innov;
    P_est = (eye(4) - K*H) * P_pred;
    x_est_hist(:,k+1) = x_est;
end

% No final transformations here (since you removed them)
est_xy = [x_est_hist(1,:)', x_est_hist(2,:)'];

error_vector = est_xy - GT_xy(1:N,1:2);
rmse_xy = sqrt(mean(sum(error_vector.^2,2)));
fprintf('RMSE (xy): %.6f m\n', rmse_xy);

figure;
plot(GT_xy(:,1), GT_xy(:,2), 'k-', 'LineWidth', 1.5); hold on;
plot(est_xy(:,1), est_xy(:,2), 'r--', 'LineWidth', 1.5);
xlabel('X Position [m]'); ylabel('Y Position [m]');
title('2D Position Estimation: Ground Truth vs. EKF Estimate');
legend('Ground Truth','EKF Estimate'); grid on; axis equal;

figure;
subplot(2,1,1);
plot(timeVec, GT_xy(:,1), 'b-', 'LineWidth', 1.5); hold on;
plot(timeVec, est_xy(:,1), 'r--', 'LineWidth', 1.5);
xlabel('Time [s]'); ylabel('X Position [m]');
title('X Position: Ground Truth vs. EKF Estimate');
legend('Ground Truth','EKF Estimate'); grid on;
subplot(2,1,2);
plot(timeVec, GT_xy(:,2), 'b-', 'LineWidth', 1.5); hold on;
plot(timeVec, est_xy(:,2), 'r--', 'LineWidth', 1.5);
xlabel('Time [s]'); ylabel('Y Position [m]');
title('Y Position: Ground Truth vs. EKF Estimate');
legend('Ground Truth','EKF Estimate'); grid on;
