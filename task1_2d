

accelData = permute(out.Sensor_ACCEL.signals.values, [3 2 1]);
timeVec   = out.Sensor_Time.time;
accelXY = accelData(:, 1:2);
validInd = ~any(isnan(accelXY), 2);
accelXY  = accelXY(validInd, :);
timeVec  = timeVec(validInd);
GT_pos = out.GT_position.signals.values;
N_gt   = size(GT_pos,1);
N_time = length(timeVec);
N      = min(N_gt, N_time);
GT_xy  = GT_pos(1:N, 1:2);
timeVec = timeVec(1:N);
accelXY = accelXY(1:N,:);

accelXY_denoised = accelXY;
for j = 1:2
    mu    = mean(accelXY(:, j));
    sigma = std(accelXY(:, j));
    lower_bound = mu - sigma;
    upper_bound = mu + sigma;
    idx_lower = accelXY(:, j) < lower_bound;
    idx_upper = accelXY(:, j) > upper_bound;
    accelXY_denoised(idx_lower, j) = lower_bound;
    accelXY_denoised(idx_upper, j) = upper_bound;
end

fc = 5;
sampleInterval = 1/mean(diff(timeVec));
accelXY_filt = lowpass(accelXY_denoised, fc, 1/sampleInterval);

tof1_raw = out.Sensor_ToF1.signals.values(:,1);
tof2_raw = out.Sensor_ToF2.signals.values(:,1);
tof3_raw = out.Sensor_ToF3.signals.values(:,1);
if isfield(out.Sensor_ToF1, 'time')
    time_tof1 = out.Sensor_ToF1.time;
else
    time_tof1 = timeVec;
end
if isfield(out.Sensor_ToF2, 'time')
    time_tof2 = out.Sensor_ToF2.time;
else
    time_tof2 = timeVec;
end
if isfield(out.Sensor_ToF3, 'time')
    time_tof3 = out.Sensor_ToF3.time;
else
    time_tof3 = timeVec;
end
tof1 = interp1(time_tof1, tof1_raw, timeVec, 'linear', 'extrap');
tof2 = interp1(time_tof2, tof2_raw, timeVec, 'linear', 'extrap');
tof3 = interp1(time_tof3, tof3_raw, timeVec, 'linear', 'extrap');

x_est = zeros(4,1);
x_est(1:2) = GT_xy(1,:)';
x_est(3:4) = [0; 0];
P_est = diag([0.1, 0.1, 0.5, 0.5]);
Q = diag([0.01, 0.01, 0.1, 0.1]);
R = diag([0.05, 0.05, 0.05]);
D_front = 2.4;
D_right = 0;
D_left  = 2.4;
x_est_hist = zeros(4, N);
x_est_hist(:,1) = x_est;

for k = 1:N-1
    dt = timeVec(k+1) - timeVec(k);
    F = [1, 0, dt, 0;
         0, 1, 0, dt;
         0, 0, 1,  0;
         0, 0, 0,  1];
    B = [0.5*dt^2, 0;
         0, 0.5*dt^2;
         dt, 0;
         0, dt];
    u = accelXY_filt(k,:)';
    x_pred = F * x_est + B * u;
    P_pred = F * P_est * F' + Q;
    z = [tof1(k+1); tof2(k+1); tof3(k+1)];
    h = [D_front - x_pred(1);
         x_pred(2) - D_right;
         D_left - x_pred(2)];
    H = [-1, 0, 0, 0;
         0, 1, 0, 0;
         0, -1, 0, 0];
    y_innov = z - h;
    S = H * P_pred * H' + R;
    K = P_pred * H' / S;
    x_est = x_pred + K * y_innov;
    P_est = (eye(4) - K * H) * P_pred;
    x_est_hist(:, k+1) = x_est;
end

x_est_trans = x_est_hist;
x_est_trans(1,:) = x_est_trans(1,:) - 1.25;
x_est_trans(2,:) = x_est_trans(2,:);
est_xy = [x_est_trans(1,:)', x_est_trans(2,:)'];

error_vector = est_xy - GT_xy(1:N, 1:2);
rmse_xy = sqrt(mean(sum(error_vector.^2, 2)));
fprintf('RMSE (xy): %.6f m\n', rmse_xy);

figure;
plot(GT_xy(:,1), GT_xy(:,2), 'k-', 'LineWidth', 1.5); hold on;
plot(est_xy(:,1), est_xy(:,2), 'r--', 'LineWidth', 1.5);
xlabel('X Position [m]');
ylabel('Y Position [m]');
title('2D Position Estimation: Ground Truth vs. EKF Estimate (Transformed)');
legend('Ground Truth', 'EKF Estimate');
grid on;
axis equal;

figure;
subplot(2,1,1);
plot(timeVec, GT_xy(:,1), 'b-', 'LineWidth', 1.5); hold on;
plot(timeVec, est_xy(:,1), 'r--', 'LineWidth', 1.5);
xlabel('Time [s]');
ylabel('X Position [m]');
title('X Position: Ground Truth vs. EKF Estimate (Transformed)');
legend('Ground Truth', 'EKF Estimate');
grid on;
subplot(2,1,2);
plot(timeVec, GT_xy(:,2), 'b-', 'LineWidth', 1.5); hold on;
plot(timeVec, est_xy(:,2), 'r--', 'LineWidth', 1.5);
xlabel('Time [s]');
ylabel('Y Position [m]');
title('Y Position: Ground Truth vs. EKF Estimate (Transformed)');
legend('Ground Truth', 'EKF Estimate');
grid on;
