import cv2
import numpy as np
import time
import serial
from collections import deque
from picamera2 import Picamera2
import os

# -----------------------------------------
# USER SETTINGS
# -----------------------------------------
pivot = (160, 60)
SMOOTHING_WINDOW = 5
PENDULUM_LENGTH_M = 1.70   # 170 cm pendulum

# Green detection range
GREEN_LOWER = np.array([40, 40, 40])
GREEN_UPPER = np.array([85, 255, 255])

# Buffers
angle_buffer = deque(maxlen=SMOOTHING_WINDOW)
velocity_buffer = deque(maxlen=SMOOTHING_WINDOW)

last_angle = None
last_time = time.time()

# -----------------------------------------
# LOAD OR ASK FOR CALIBRATION FACTOR (K)
# -----------------------------------------
CAL_FILE = "calibration.txt"

if os.path.exists(CAL_FILE):
    with open(CAL_FILE, "r") as f:
        K = float(f.read().strip())
    print(f"[OK] Loaded calibration factor K = {K}")
else:
    print("No calibration found.")
    K = float(input("Enter calibration factor K (e.g., 0.5): ").strip())
    with open(CAL_FILE, "w") as f:
        f.write(str(K))
    print(f"[SAVED] Calibration factor stored.")

# -----------------------------------------
# SERIAL SETUP
# -----------------------------------------
SERIAL_PORT = "/dev/ttyACM0"  # change if needed
BAUD = 115200

try:
    ser = serial.Serial(SERIAL_PORT, BAUD, timeout=1)
    print(f"[OK] Serial connected to {SERIAL_PORT}")
except Exception as e:
    print(f"[WARNING] Serial not available: {e}")
    ser = None

# -----------------------------------------
# INITIALISE CAMERA
# -----------------------------------------
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(main={"size": (320, 240)}))

try:
    picam2.start()
    time.sleep(1)
    print("Camera started.")
except Exception as e:
    print("Camera failed to start:", e)
    exit()

print("Tracking GREEN pendulum bob...")

# -----------------------------------------
# MAIN LOOP
# -----------------------------------------
while True:
    frame = picam2.capture_array()
    frame = frame[20:220, 40:280]  # crop
    display = frame.copy()

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, GREEN_LOWER, GREEN_UPPER)
    mask = cv2.GaussianBlur(mask, (7, 7), 0)
    mask = cv2.erode(mask, None, iterations=1)
    mask = cv2.dilate(mask, None, iterations=2)

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                   cv2.CHAIN_APPROX_SIMPLE)

    cx = cy = None

    if contours:
        c = max(contours, key=cv2.contourArea)
        area = cv2.contourArea(c)

        if area > 100:
            M = cv2.moments(c)
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            cv2.circle(display, (cx, cy), 6, (0, 255, 0), -1)
            cv2.circle(display, pivot, 6, (255, 255, 0), -1)
            cv2.line(display, pivot, (cx, cy), (255, 255, 0), 2)

            # -------------------------
            # ANGLE CALCULATION
            # -------------------------
            dx = cx - pivot[0]
            dy = pivot[1] - cy

            angle_rad = np.arctan2(dx, dy)
            angle_buffer.append(angle_rad)
            smooth_angle_rad = np.mean(angle_buffer)

            # -------------------------
            # ANGULAR VELOCITY
            # -------------------------
            now = time.time()
            dt = now - last_time
            last_time = now

            if last_angle is None:
                last_angle = smooth_angle_rad
                ang_vel_raw = 0
            else:
                dtheta = smooth_angle_rad - last_angle
                last_angle = smooth_angle_rad

                ang_vel_raw = dtheta / dt

            velocity_buffer.append(ang_vel_raw)
            ang_vel_smooth = np.mean(velocity_buffer)

            # -------------------------
            # LINEAR VELOCITY (before calibration)
            # -------------------------
            linear_vel = ang_vel_smooth * PENDULUM_LENGTH_M

            # -------------------------
            # APPLY CALIBRATION + CLIP NEGATIVES
            # -------------------------
            calibrated_vel = K * linear_vel

            if calibrated_vel < 0:
                calibrated_vel = 0.0  # clip negative values to zero

            # -------------------------
            # PRINT + SERIAL
            # -------------------------
            print(f"{calibrated_vel:.3f} m/s")

            if ser is not None:
                try:
                    ser.write(f"{calibrated_vel:.3f}\n".encode())
                except:
                    pass

            cv2.putText(display, f"v: {calibrated_vel:.2f} m/s",
                        (10, 50), cv2.FONT_HERSHEY_SIMPLEX,
                        0.7, (0, 255, 0), 2)

    cv2.imshow("Mask", mask)
    cv2.imshow("Tracking", display)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

picam2.close()
cv2.destroyAllWindows()

if ser:
    ser.close()
